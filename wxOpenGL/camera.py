"""
Common camera movement terms

                                 DOLLY

                              -==-
                         .+=:       .=
                       +........-.     +        :+-.   :=:
                     *............::     .    *-----.      ::
                    -...............:     :+...........-     -
                    =...............:: :-+...............:.    -
                    =...............::--*.................:-    -
                    +...............::.+..................:::   :
                     =.................+ .................::::   :
                      -................=:..................:::.. :
                        =.............-+=...................:.. :
                         =+.........:*:-=*...................-..
                          *... ====-------+:................:+
                          *.....:::.    .:--*:.............=
                .-*#%%#*  #.............:::.  .+-.......-=
        =*#%#######%%=    =.....................:- .  .
        #**################:.....................:  ::+=-:-  .+-
        #*******###########-.....................- -+....:   = *
       .****%###*##########......................--:-...:   =  *
       -#**    .#%#####*###=:::..................-*+-::::   .  =
       .-           .:*%#####**#=:...............-**-:--.  *  -       :.
                            +%######*++-.........=-=%-:-:..+  #:     -**+
                                   :#%####**#-...=#####*--:+ #******#****#
                                         :#%####**########%%#**************:
                                               -%#*###***********************
                                                     :#%####*****************#
                                                           .*%##%**********##*#
                                                               #******#**##-
                                                              **#***#=
                                                             -#+.

                                 PEDISTAL
                                            **
                                         ******=
                                      ***********.
                                  .#***************
                                     .=##***********=
                                       -#********#%#*#
                                       -#*******-...:=-=-
                                       =#*****.....::::-    -
                                  +----+#***:......::::::    :
                                :------+#**=.......::::::     -
                                =:-----+#*+........:::::.:    :
                               -.:-----##*+........:::..:     :
                               .::-----+#**=.......:::.:     -
                                -:-----+#**#+.........-....:-
                                 :=:::-*#*+##%+-..::-----=:
                                 -...::+#.....::: ::::::.
                                 :...:-+#....::-:     -: :-:-=.
                                 -...:-+#....::-:  +::  -...   =
                                 -...:-*#....::-:.+:-  +    .  :.
                                 -...:-+#.....:-:-*-=::+    .  ..
                                 :..::-+#...:::----*--:+.      +
                                     . =#+-....:--:::-#:=.   :-
                                       -#*********
                                       -#********* .-+:
                                       -#************.
                                  #%#**************=
                                    =*************
                                       -********:
                                          :***=


                                   TRUCK

                                     .::-.
                                .-+       :
                                -..+       -
                                -...+       .
                                :...::      -
                                 :....:      +
                                 -....=:++-:.    .
                                  =...:-.=:        :
                                 - :..::..:+        .
                                 :- :.::....=       .
                                  :- =+-.....:       -   .**#+.
                                  -.:  +.....=             ******#=
                                  =.:: .......-       #***************-
                                  -..-. =.....=       +***************
                                  ::..-  :....=       -***************
                                :+##...- :....-       **********##***.
            :*:         .-+#*********...-.:...=      .****#*=:   :#*#
           =***  .-+*****************+...  .:.= .:*##+-.          .*=
          ****************************+.:  -=:...--
         ******************************-: +:....    -
        **************************=.    -.=::    :==-=
      -********************+-            .=   =       *
       :#************=.                   - +.  .    -
          .*#*****                         +       =
              +#**+                          :--.
                 -#.

                           PAN

                      *=+-      -
                     %....+     -##--::.. :-
                     =....:+   :....#        -
                    .-.....:- -......+        -
                     :......*=........*        :
                     =......==........:=       .
                     #......:-........:#        -
                      #......+.........:*       .
                       #....+::.........#       :
                       =*-.=--#.........*       =
                       +..:+:  --.......=      :
                       *.....:#  *.....%  ...=
                       *........==-%-=*+=:.-
                       *.........+         -
                       *.........+         -
                       #.........+  .*:+=    .*
                        :+.......+ ==+:  *-:.   -
                          ==.....* @=: #-        -
                            +-...* ** +:         ..            :=+**:
                              #:.*.:=.+.     .   +     *##*************#=
                                #*.-*:= .  .    =       .-=+#**************#*.
                                 .   :+        =           ***************+***#
                                       --..:=-           -**************#
                                                       =****************#
                         -                          =******************#
                     =#*#*                     -*#********************#
                 =*****##:.          .:-=**#************************#+
             -******************************************************
           ******************************************************=
           ************************************************#***.
           +*******************************************#**#=
           -*******************************************:
            ********************************++**+-
            #**#    .:=+***##***###*+++-:.
            *#*
            -+

                        TILT
                                                              .=.
                                                         :+####:
                                                    -*#######+
                                                  *#########%:
                                --::::-=:        =#############:
                .----.       ::.....::.:.::-.    +##############*
             .-:....:.:-:-. -............::: =  .*################.
            =..........:-  =.............:::. =.=##################=
           =...........::-+..............:::- :++##%*###############=
          -............:::=.................- .=#%:  +###############=
          -............:::=.................: :*=     =*##############:
          -..............:+................-  :=       :*#############%
          -.............:---..............-  .+         :*#############*
           -...........::---=............-..:+           =*############%
            =:........-:---+ .=.......--:--+              +#############=
              =+==++*++==--:::....- -:-#:                 -*#############
              -...................-    +  ==+*-            *############%
              -...................-   ---  =..:*           *############%
              -...................-.-::::  ::----          +############%.
              -...................-+*---..-. =::=          +############%.
              :...................-*+:---:-: --:=          *############%
              -...................--**--+::*.:-=:         .*############%
              :...................-----*=+--+ :=          =*############*
                     ... ........                        .+############%.
                                                        -*#############*
                                               ..      =*##############
                                               :*#   +##############%.
                                                +###*##############%
                                                =#################%
                                                .*###############*
                                                 +#############*
                                                 .*###########
                                                    :+#######*
                                                          :+###+

"""

from typing import TYPE_CHECKING

import wx
import math
from OpenGL import GL
from OpenGL import GLU

import numpy as np

from .geometry import point as _point
from .geometry import angle as _angle
from .geometry import line as _line
from . import Config


if TYPE_CHECKING:
    from . import canvas as _canvas

ZERO_POINT = _point.ZERO_POINT


class Camera:
    __doc__ = __doc__

    def __init__(self, canvas: "_canvas.Canvas"):
        self.canvas = canvas
        self._context = canvas.context

        self._is_dirty = True
        self._projection = None
        self._modelview = None
        self._viewport = None
        self._clip = None
        self._up = None
        self._right = None
        self._forward = None

        self._up_norm = None
        self._right_norm = None
        self._forward_norm = None
        self._frustum_planes = None

        self._position = _point.Point(0.0, Config.eye_height, 0.0)

        self._eye = _point.Point(0.0, Config.eye_height + 0.5, 75.0)

        self._angle = _angle.Angle.from_points(self._position, self._eye)

        self._angle_from_center = _angle.Angle.from_points(ZERO_POINT.copy(), self._eye)
        self._focal_distance = _line.Line(self._eye, self._position).length()
        self._distance_from_center = _line.Line(ZERO_POINT, self._eye).length()

        self._calculate_camera()

        self._position.bind(self._update_camera)
        self._eye.bind(self._update_camera)

    def Reset(self):
        with self._position and self._eye:
            self._position.x = 0.0
            self._position.y = Config.eye_height
            self._position.z = 0.0

            self._eye.x = 0.0
            self._eye.y = Config.eye_height + 0.5
            self._eye.z = 75.0

        self._update_camera(None)

    def _update_camera(self, _=None):
        if self._context.is_locked:
            self._is_dirty = True
        else:
            wx.CallAfter(self.canvas.Refresh, False)

    @property
    def orthonormalized_axes(self):
        def normalize(v):
            v = np.array(v, dtype=float)
            n = np.linalg.norm(v)
            return v / (n if n != 0 else 1.0)

        # Returns forward, right, up (all unit) with forward pointing from eye -> center
        f = normalize((self._position - self._eye).as_numpy)
        r = normalize(np.cross(f, self._up))  # camera right  # NOQA
        u = np.cross(r, f)  # camera up re-orthonormalized  # NOQA
        return f, r, u

    def GetObjectsInView(self, objs: list) -> list:
        if self._clip is None:
            self._is_dirty = True

        if self._is_dirty:
            self._update_views()

        planes = self._frustum_planes
        aabb_in_frustum_planes = self._aabb_in_frustum_planes
        res = [
            [_line.Line(self._eye, obj.position).length(), obj] for obj in objs
            if any(aabb_in_frustum_planes(mn.as_float, mx.as_float, planes)
                   for mn, mx in obj.rect)]

        # sort the objects by distance from the camera
        res = sorted(res, key=lambda o: o[0])

        # we need to have the order as far -> near, we also trim off the distance
        # that was used for saorting
        res = [res[i][1] for i in range(len(res) - 1, -1, -1)]

        ret = []
        offset = 0
        for obj in res:
            for renderer in obj.triangles:
                if renderer.is_opaque:
                    ret.insert(offset, obj)
                    offset += 1
                else:
                    ret.append(obj)

        return ret

    @staticmethod
    def _aabb_in_frustum_planes(mn_xyz, mx_xyz, planes: np.ndarray) -> bool:
        """
        mn_xyz, mx_xyz: array-like shape (3,)
        planes: (6,4) from extract_frustum_planes

        Returns True if intersects / inside, False if fully outside.
        """
        mn = np.asarray(mn_xyz, dtype=np.float64)
        mx = np.asarray(mx_xyz, dtype=np.float64)

        c = (mn + mx) * 0.5
        e = (mx - mn) * 0.5

        # normals and ds
        n = planes[:, 0:3]  # (6,3)
        d = planes[:, 3]  # (6,)

        # signed distance from center to each plane
        s = (n @ c) + d  # (6,)

        # projected radius of extents onto plane normal
        r = (np.abs(n) @ e)  # (6,)

        # if outside any plane -> reject
        return np.all((s + r) >= 0.0)

    @staticmethod
    def _extract_frustum_planes(view_proj: np.ndarray) -> np.ndarray:
        """
        Returns planes as an array shape (6,4): [A,B,C,D] per plane.
        Planes are normalized (A,B,C length = 1).

        Order: left, right, bottom, top, near, far
        """
        m = np.asarray(view_proj, dtype=np.float64)

        # rows
        r0 = m[0, :]
        r1 = m[1, :]
        r2 = m[2, :]
        r3 = m[3, :]

        planes = np.stack([(r3 + r0),  # left
                          (r3 - r0),  # right
                          (r3 + r1),  # bottom
                          (r3 - r1),  # top
                          (r3 + r2),  # near  (OpenGL style)
                          (r3 - r2),  # far
                           ], axis=0)

        # normalize planes
        n = np.linalg.norm(planes[:, 0:3], axis=1)
        planes = planes / n[:, None]

        return planes

    @staticmethod
    def _aabb_intersects_frustum(ht_rects: list, view_proj: np.ndarray) -> bool:
        """
        NO LONGER USED, KEEPING FOR LATER POSSIBLE USE
        Return True if ANY AABB in ht_rects intersects the view frustum defined
        by view_proj (projection @ view).

        ht_rects: iterable of AABBs, each AABB being (min_point, max_point)
                  where min_point/max_point have .x/.y/.z

        view_proj: 4x4 numpy array (projection @ view), dtype float32/float64
        """
        # ensure matrix dtype for corners creation
        dtype = view_proj.dtype

        for ht_rect in ht_rects:
            # unpack min/max points
            mn = ht_rect[0]
            mx = ht_rect[1]

            corners = np.array(
                [
                    [float(mn.x), float(mn.y), float(mn.z), 1.0],
                    [float(mn.x), float(mn.y), float(mx.z), 1.0],
                    [float(mn.x), float(mx.y), float(mn.z), 1.0],
                    [float(mn.x), float(mx.y), float(mx.z), 1.0],
                    [float(mx.x), float(mn.y), float(mn.z), 1.0],
                    [float(mx.x), float(mn.y), float(mx.z), 1.0],
                    [float(mx.x), float(mx.y), float(mn.z), 1.0],
                    [float(mx.x), float(mx.y), float(mx.z), 1.0],
                ], dtype=dtype
            )  # (8,4)

            clip = (view_proj @ corners.T).T

            w = clip[:, 3]

            eps = 1e-8
            front = w > eps

            if not np.any(front):
                continue  # whole box behind camera

            ndc = clip[front, :3] / w[front, None]

            x = ndc[:, 0]
            y = ndc[:, 1]
            z = ndc[:, 2]

            if (
                np.all(x < -1.0) or np.all(x > 1.0) or
                np.all(y < -1.0) or np.all(y > 1.0) or
                np.all(z < -1.0) or np.all(z > 1.0)
            ):
                continue

            # if we get here, this AABB is at least partially inside -> we can return True
            return True

        # none of the AABBs intersect
        return False

    def Set(self):
        self._calculate_camera()
        camera = self._eye.as_float + self._position.as_float + tuple(self._up.tolist())
        GLU.gluLookAt(*camera)
        self._update_views()

    def _calculate_camera(self):
        eye = self._eye.as_numpy
        pos = self._position.as_numpy

        forward = pos - eye

        fn = np.linalg.norm(forward)
        if fn < 1e-6:
            return

        forward = forward / fn

        gf = np.linalg.norm(forward)
        if gf < 1e-6:
            forward_ground = np.array([0.0, 0.0, -1.0],
                                      dtype=np.dtypes.Float64DType)
        else:
            forward_ground = forward / gf

        self._forward_norm = gf

        world_up = np.array([0.0, 1.0, 0.0],
                            dtype=np.dtypes.Float64DType)

        right = np.cross(world_up, forward_ground)  # NOQA

        rn = np.linalg.norm(right)
        if rn < 1e-6:
            right = np.array([1.0, 0.0, 0.0],
                             dtype=np.dtypes.Float64DType)
        else:
            right = right / rn

        self._right_norm = rn

        up = np.cross(forward_ground, right)  # NOQA

        un = np.linalg.norm(up)
        if un < 1e-6:
            up = np.array(
                [0.0, 1.0, 0.0],
                dtype=np.dtypes.Float64DType
            )
        else:
            up = up / un

        self._up_norm = un

        self._up = up
        self._right = right
        self._forward = forward_ground

        self._focal_distance = _line.Line(self._eye, self._position).length()

    def _update_views(self):
        if not self._is_dirty:
            return

        self._calculate_camera()
        with self._context:
            self._is_dirty = False
            self._viewport = np.ascontiguousarray(GL.glGetIntegerv(GL.GL_VIEWPORT))
            self._projection = np.ascontiguousarray(np.array(GL.glGetDoublev(GL.GL_PROJECTION_MATRIX)).reshape((4, 4), order="F").T)
            self._modelview = np.ascontiguousarray(np.array(GL.glGetDoublev(GL.GL_MODELVIEW_MATRIX)).reshape((4, 4), order="F").T)
            self._clip = (self._projection @ self._modelview).astype(np.float32)
            self._frustum_planes = self._extract_frustum_planes(self._clip)

    def Rotate(self, dx, dy):
        """
        Moves the camera position keeping the focused point locked.
        """
        self._is_dirty = True
        eye = self._rotate_about(dx, dy, self._eye, self._position)
        self._eye += eye - self._eye

    @staticmethod
    def _rotate_about(dx: int, dy: int, p1: _point.Point, p2: _point.Point) -> np.ndarray:
        """
        Moves the camera position keeping the focused point locked.
        """
        # This is a constant that can be adjusted. This is a hard limit
        # to prevent gimbal lock from occuring when looking straight up or
        # straight down. You can set it to a smaller number but do not increase
        # it past 89.9 otherwise gimbal lock can occur.
        p1 = p1.as_numpy
        p2 = p2.as_numpy

        max_pitch = 89.9

        offset = p1 - p2
        dist = np.linalg.norm(offset)

        if dist < 1e-6:
            return np.array([0.0, 0.0, 0.0], dtype=np.float64)

        up = np.array([0.0, 1.0, 0.0], dtype=np.float64)

        def _rodrigues(v, k, angle_rad):
            k = k / np.linalg.norm(k)
            cos_a = math.cos(angle_rad)
            sin_a = math.sin(angle_rad)  # NOQA
            return ((v * cos_a) + (np.cross(k, v) * sin_a) +  # NOQA
                    (k * (np.dot(k, v)) * (1.0 - cos_a)))

        yaw_offset = _rodrigues(offset, up, math.radians(dx))
        yaw_offset_n = np.linalg.norm(yaw_offset)

        if yaw_offset_n < 1e-6:
            return np.array([0.0, 0.0, 0.0], dtype=np.float64)

        yaw_dir = yaw_offset / yaw_offset_n

        horiz_len = math.hypot(yaw_dir[0], yaw_dir[2])

        cur_pitch_deg = math.degrees(math.atan2(yaw_dir[1], horiz_len))

        desired_pitch = cur_pitch_deg + dy
        if desired_pitch > max_pitch or desired_pitch < -max_pitch:
            # block pitch movement entirely (yaw still applies)
            dy = 0.0

        if abs(dy) < 1e-6:
            final_offset = yaw_dir * dist
        else:
            right = np.cross(yaw_dir, up)  # NOQA
            rn = np.linalg.norm(right)
            if rn < 1e-6:
                final_offset = yaw_dir * dist
            else:
                right = right / rn
                rotated = _rodrigues(yaw_offset, right, math.radians(dy))

                rnorm = np.linalg.norm(rotated)
                if rnorm < 1e-6:
                    final_offset = yaw_dir * dist
                else:
                    # explicitly restore original distance to avoid shrink/grow
                    final_offset = rotated * (dist / rnorm)

        new_point = p2 + final_offset

        return _point.Point(new_point[0], new_point[1], new_point[2])

    def PanTilt(self, dx, dy):
        """
        Moves the camera position keeping the focused point locked.

        Pan and Tilt camera movements.
        """
        self._is_dirty = True
        position = self._rotate_about(dx, dy, self._position, self._eye)
        self._position += position - self._position

    def Zoom(self, delta, *_):
        """
        This has a similiar movement appearance as Dolly except there are hard
        limits as to how far it is able to move where as Dolly does not.
        This also doesn't change the camera position at all. It simply shinks
        or expands the distance between the focal point and the camera position.
        """
        move = self._forward * float(delta)

        # If moving would invert eye and pos, prevent crossing pos
        if delta > 0 and self._focal_distance <= 0.1:
            return
        elif delta < 0 and self._focal_distance >= 150.0:
            return

        self._is_dirty = True
        self._eye += move

    def Walk(self, dx, dy, speed):
        """
        This movement is a bit tricky to explain in terms of camera movement.
        If you think about what you do as a person when you walk this will
        mimick as close as I could get to that movement. so basically if you
        want to walk straight forward and back you get that from this function.
        That is the same as a Dolly camera movement.

        if you go left and right the movement you get is as if you are turning
        on the ball of your foot. This is comparable to the "Pan" movement of a
        camera.

        If you hold left or right and press up or down at the same time you get
        a combination of the 2 above movements. kind of like what it would be
        like when you walk in an arc to either left or right.
        """

        # Build desired move from input
        input_mag = math.sqrt((dx * dx) + (dy * dy))
        if input_mag == 0:
            return

        move_dir = self._right * float(dx) + self._forward * float(dy)

        mdn = np.linalg.norm(move_dir)
        if mdn < 1e-6:
            return

        move_dir = move_dir / mdn
        move = move_dir * (input_mag * speed)

        self._is_dirty = True
        with self._eye and self._position:
            self._eye += move
            self._position += move

    def TruckPedestal(self, dx, dy, speed):
        """
        this is as the function name states. It is a Truck (left right)
        and a Pedestal (up down) movement
        """

        # Build desired move from input
        input_mag = math.sqrt((dx * dx) + (dy * dy))
        if input_mag == 0:
            return

        move_dir = self._right * float(dx) + self._up * float(dy)

        mdn = np.linalg.norm(move_dir)
        if mdn < 1e-6:
            return

        move_dir = move_dir / mdn

        move = move_dir * (input_mag * speed)

        with self._eye:
            self._eye += move

        self._is_dirty = True
        self._position += move

    def ProjectPoint(self, point: _point.Point) -> _point.Point:
        """
        Project a world-space _point.Point to window coordinates (top-left origin).
        Returns (winx, winy_top, winz) where winz is in [0,1].
        """

        with self._context:
            winx, winy, winz = GLU.gluProject(point.x, point.y, point.z,
                                              self._modelview, self._projection, self._viewport)

        # convert to top-left origin to match wx mouse coordinates
        winy_top = self._viewport[3] - winy
        return _point.Point(winx, winy_top, winz)

    def UnprojectPoint(self, point: _point.Point) -> _point.Point:
        """
        Unproject window coordinates (top-left origin) and
        winz back to a world _point.Point.
        """

        with self._context:
            # convert top-left y back to OpenGL bottom-left y
            winy = self._viewport[3] - point.y

            x, y, z = GLU.gluUnProject(point.x, winy, point.z,
                                       self._modelview, self._projection, self._viewport)

        return _point.Point(x, y, z)
